学习笔记

## 动态规划思路

1、根据大问题找重复子问题

2、定义dp状态数组，明确dp[i]含义

3、找dp方程，明确边界条件等，不同处理


## 动态规划解题步骤

### 判断边界条件

1、给的值为空，提前返回

2、长度为1这种特殊值

### 初始化dp

#### 初始化一维dp数组， dp=[]，要明白dp[i]的意义
初始化方式: 
	新开数组，并赋上初始0值，然后迭代修改
	以原数组直接为dp（优化空间复杂度，不过会修改原数组的值）
例：
	1、爬楼梯问题：
		新开数组，dp[i]代表，第i个数的斐波那契数值，最后迭代到dp[i]即可
		初始化dp[0]=1,dp[1]=1,第一个数是1，0是用于初始计算，n是正整数
	2、打家劫舍问题：
		新开dp数组，dp[i]表示当前的最大值，初始化0值，1值（要不偷0，要不偷1，两个的最大值）
		不开dp数组，直接nums为dp，初始化nums[1]=max(nums[0], nums[1])
	3、零钱兑换问题：
		新开dp，初始化一个amount+1的数组，dp[i]组成该金额的最小组合，最终结果是dp[amount]
		金额依次递增，算出每个金额的最小组合，索引即代表金额



#### 一维dp数组通过优化，可将空间复杂度降为1，通过指针迭代
要明白每个指针的意义，以及特殊问题相关
一般都会2个-3个指针，分别代表，现在的值，前一个值，结果值或后一个值，迭代过程中不断更新指针值
例：
	1、爬楼梯问题：
		对于上面开数组的优化， a,b,c 三个指针，n是正整数，初始化a=0，b=1，c=1
		a：n-2， b：n-1， c：n
	2、打家劫舍问题：
		数组优化，两个指针cur,pre,pre前一个，cur当前个
	3、最大子序和问题：
		不需要初始化数组，根据特殊情况，双指针迭代，或者单指针，修改数组，循环中舍弃不符合条件的值
		res最终结果，sum当前和，res初始化数组第一个值，从第二个开始
	4、最大乘积和：
		初始化一个最大值，一个最小值，结果，三个值，处理正负数的问题


#### 初始化二维dp数组，dp=[][]int, dp[i][j]的意义
例：
	1、打家劫舍问题（一维问题二维化）：
		初始化dp数组，dp=[][]int,升维思路记录额外数据，dp[i][0,1],0代表不偷，1代表偷
		并初始化0值,dp[0][0],dp[0][1],初始值偷与不偷的情况
	2、三角形最小路径和问题：
		初始化dp数组[][]int,并将最后一行赋值，逆向循环，从倒数第二行开始
		不开dp数组，直接triangle，不需要赋值了
		优化空间复杂度，只需dp[],初始化最后一层，记录每一层，逆向循环，整层更新掉
	3、回文子串（一维问题二维化）：



### 循环迭代dp值

根据循环方向不同，循环初始值不同，结束值不同，维度不同分多这种情况

每次循环处理dp方程,区分情况，注意边界条件，分治，可能各个条件的dp方程不一样

注意dp[i]的意义，根据循环的正序，倒序返回

#### 一维循环：从开始往后循环，i++

例：
	1、爬楼梯问题:
		初始值，初始到了dp[1]，从2开始循环到n，返回dp[n]，初始的数组要到n+1
		dp方程：dp[i] = dp[i-1] + dp[i-2]
		返回dp[n]
		指针形式：c就相当于n的值，初始化了1的值，从1开始循环到n
		先更新值，然后计算
		a = b
		b = c
		c = a + b
		返回c
	2、打家劫舍问题：
		初始化是二维数组：
		dp[i]每次计算偷与不偷的情况，最后返回偷与不偷的最大值，从i=1开始，正向
		dp方程：	dp[i][0] = max(dp[i-1][0], dp[i-1][1]) // i不偷，i-1偷与不偷之间的最大值
        		dp[i][1] = nums[i] + dp[i-1][0] // i偷，则当前i加上i-1不偷的值
        初始化是一维数组：
        dp[i]是代表最大值，不关心偷与不偷，只获取偷和，不偷的最大值， i-2包含了i-3，i-4等
        dp方程：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        不开dp数组，直接nums为dp 初始化nums[1]： 
        dp方程：nums[i] = max(nums[i-1], nums[i-2] + nums[i])
        指针pre          ，cur从2开始循环：
        dp方程：pre, cur = cur, max(cur, pre + nums[i])
    3、最大子序和：
    	res记录结果，sum当前值，然后对sum进行累加，如果sum累加之后小于0，则把从下一个值从新开始，赋值为sum
    	比较结果，更新res
    	另一种思路：更新nums[i],进行累加nums[i] + nums[i-1] > nums[i]，说明nums[i-1]是正数，否则nums[i-1]是负数
    	则不动，nums[i]就是dp[i]代表累加和
    4、最大乘积和：
    	每次循环，获取当前的最大，最小值，每次更新最大最小值 
    	最大值：比较最大值*当前值，当前值，当前值*最小值的大小，针对0，变号的处理
    	最小值：比较最小值*当前值，当前值，当前值*最大值的大小，针对0，变号的处理
    	另外思路：负数的个数，偶数则是全部最大，奇数则从前，从后连乘，舍弃1个负数的两种情况的最大值



#### 一维循环：从后往前循环，i--

#### 二维循环：从前往后循环，i--

例：
	1、零钱兑换问题：
    外层循环：从第一个金额开始向后遍历，每个金额初始dp[i] = -1
    内层循环：遍历硬币数组当前金额即索引小于硬币数，则为-1跳过或者减去这个硬币金额后前一个也无解是-1
    		 前一个有解的话，就是前一个所需的最小组合数+1，如果这个数字小于dp[i],或者dp[i]没有计算过,则更新dp[i]
   	最后返回amount索引的金额

#### 二维循环：从后往前循环，i--

自下向上循环，注意初始值的处理，看看最后一层是不是需要进入循环，不进入直接初始化最后一层

例：
	1、最小三角形路径和：
	外层循环从倒数第二层开始。n-2往前，里层循环正向，dp[i][j]为下一层相邻的最小值
	dp方程：dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]
	优化空间复杂度：dp[]初始化最后一层，向上循环，每次整层更新
	dp方程：dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]